<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Area 53 Minigame - Level 2</title>
  <style>
    body {
      margin: 0;
      background-color: #000;
      overflow: hidden;
      font-family: 'Courier New', Courier, monospace;
      color: #0f0;
    }
    
    #loading-screen {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
    }
    
    #loading-text {
      font-size: 1.5em;
      margin-bottom: 15px;
      text-shadow: 0 0 5px #0f0;
    }
    
    #loading-cursor {
      display: inline-block;
      width: 0.7em; height: 1.2em;
      background-color: #0f0;
      margin-left: 5px;
      vertical-align: bottom;
      animation: cursor-blink .8s infinite;
      box-shadow: 0 0 5px #0f0;
    }
    
    @keyframes cursor-blink {
      0%,50% { opacity: 1; }
      51%,100% { opacity: 0; }
    }
    
    #dvd-screensaver {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 5;
      pointer-events: none;
    }
    
    #dvd-logo {
      position: absolute;
      width: 150px;
      height: 80px;
      opacity: 0.7;
      transition: fill 0.5s ease;
    }
    
    #dvd-logo path {
      fill: #ff0000;
    }
    
    #corner-video-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 50;
      backdrop-filter: blur(5px);
    }
    
    #corner-video {
      max-width: 80%;
      max-height: 80%;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
    }
    
    #axex-img {
      position: absolute;
      bottom: 10px;
      left: 10px;
      width: 100px;
      height: auto;
      z-index: 15;
      opacity: 0.9;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      transition: transform 0.2s ease;
    }
    
    #axex-img:hover {
      transform: scale(1.1);
    }
    
    /* Retro Clock Styles */
    #retro-clock {
      position: absolute;
      top: 15px;
      left: 15px;
      z-index: 25;
      padding: 10px 14px;
      background: rgba(0, 20, 10, 0.8);
      border: 2px solid #0f0;
      border-radius: 6px;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.5), inset 0 0 8px rgba(0, 80, 0, 0.3);
      font-family: "Courier New", monospace;
      color: #0f0;
      text-shadow: 0 0 5px #0f0;
      line-height: 1.2;
      transform: perspective(500px) rotateX(5deg) rotateY(-2deg);
      backdrop-filter: blur(1px);
      transition: all 0.3s ease;
    }
    
    #retro-clock:hover {
      transform: perspective(500px) rotateX(0deg) rotateY(0deg) scale(1.05);
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.7);
    }
    
    #clock-time {
      font-size: 28px;
      letter-spacing: 2px;
      font-weight: bold;
      margin-bottom: 2px;
      background: linear-gradient(to bottom, #0f0, #0a0);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 8px rgba(0, 255, 0, 0.8);
    }
    
    #clock-date {
      font-size: 15px;
      text-align: center;
      opacity: 0.9;
      letter-spacing: 1px;
      border-top: 1px solid rgba(0, 255, 0, 0.3);
      padding-top: 3px;
    }
    
    #game-container {
      width: 100%;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      opacity: 0;
      transition: opacity .5s ease-in;
      z-index: 2;
    }
    
    #game-container.visible {
      opacity: 1;
    }
    
    canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      background: #0a0a0a;
      box-shadow: 0 0 15px rgba(0,255,0,.3);
      z-index: 4;
    }
    
    #textbox {
      position: absolute;
      bottom: 20px; left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,.85);
      color: #0f0;
      padding: 10px 20px;
      font-size: 1.1em;
      border: 1px solid #0f0;
      z-index: 10;
      max-width: 90%;
      box-shadow: 0 0 8px #0f0;
      text-align: center;
    }
    
    #audio-player {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0,0,0,.85);
      border: 2px solid #0f0;
      border-radius: 8px;
      padding: 15px;
      width: 280px;
      color: #0f0;
      box-shadow: 0 0 15px rgba(0,255,0,.6);
      z-index: 20;
      backdrop-filter: blur(5px);
    }
    
    #audio-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      border-bottom: 1px solid rgba(0,255,0,0.4);
      padding-bottom: 8px;
    }
    
    #audio-title {
      font-size: 16px;
      text-shadow: 0 0 5px #0f0;
    }
    
    #audio-equalizer {
      display: flex;
      gap: 3px;
      align-items: flex-end;
      height: 20px;
    }
    
    .eq-bar {
      width: 4px;
      background-color: #0f0;
      box-shadow: 0 0 5px #0f0;
    }
    
    #audio-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    #audio-buttons {
      display: flex;
      gap: 8px;
    }
    
    #audio-play, #audio-stop {
      flex: 1;
      background-color: rgba(0, 40, 0, 0.5);
      border: 1px solid #0f0;
      color: #0f0;
      padding: 8px 5px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      cursor: pointer;
      text-shadow: 0 0 5px #0f0;
      transition: all 0.2s ease;
      border-radius: 4px;
    }
    
    #audio-play:hover, #audio-stop:hover {
      background-color: rgba(0, 255, 0, 0.2);
      box-shadow: 0 0 10px #0f0;
    }
    
    #audio-play.active {
      background-color: rgba(0, 255, 0, 0.3);
      text-shadow: 0 0 8px #0f0;
      box-shadow: 0 0 8px rgba(0, 255, 0, 0.6) inset;
    }
    
    #audio-time {
      font-size: 12px;
      text-align: center;
      margin-top: 8px;
    }
    
    #audio-progress-container {
      width: 100%;
      height: 8px;
      background: rgba(0, 30, 0, 0.5);
      border-radius: 4px;
      overflow: hidden;
    }
    
    #audio-progress {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, #0f0, #0f9);
      box-shadow: 0 0 5px #0f0;
      transition: width 0.3s linear;
    }
    
    #volume-container {
      width: 100%;
      padding: 5px 0;
      position: relative;
    }
    
    #volume-slider {
      width: 100%;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: linear-gradient(to right, #0f0 0%, #0f0 70%, #043 100%);
      outline: none;
      opacity: 0.9;
      transition: opacity 0.2s;
      border-radius: 3px;
      box-shadow: 0 0 5px rgba(0, 255, 0, 0.5) inset;
    }
    
    #volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: radial-gradient(#0f0, #063);
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(0, 255, 0, 0.8);
    }
    
    #play-again-button {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background-color: transparent;
      border: none;
      color: #0f0;
      padding: 15px 30px;
      font-family: 'Courier New', monospace;
      font-size: 24px;
      cursor: pointer;
      text-shadow: 0 0 8px #0f0;
      transition: all 0.2s ease;
      z-index: 30;
    }
    
    #play-again-button:hover {
      color: #fff;
      text-shadow: 0 0 15px #0f0, 0 0 5px #0f0;
      transform: translateX(-50%) scale(1.1);
    }
    
    #play-again-button:active {
      transform: translateX(-50%) scale(1.05);
    }
  </style>
</head>
<body>
  <div id="game-container" class="visible">
    <canvas id="gameCanvas" width="768" height="576"></canvas>
    <div id="textbox">thats our project. enjoy our podcast (:</div>
    
    <div id="audio-player">
      <div id="audio-header">
        <div id="audio-title">üßôüèøWizard 89.3üßô‚Äç‚ôÇÔ∏è</div>
        <div id="audio-equalizer"></div>
      </div>
      <div id="audio-controls">
        <div id="audio-progress-container">
          <div id="audio-progress"></div>
        </div>
        <div id="audio-time">00:00 / 00:00</div>
        <div id="audio-buttons">
          <button id="audio-play">PLAY</button>
          <button id="audio-stop">STOP</button>
        </div>
        <div id="volume-container">
          <input type="range" id="volume-slider" min="0" max="100" value="70">
        </div>
      </div>
    </div>
    
    <div id="play-again-button">> PLAY AGAIN</div>
  </div>
  
  <div id="dvd-screensaver">
    <svg id="dvd-logo" viewBox="0 0 210 118" xmlns="http://www.w3.org/2000/svg">
      <path d="M118.895,20.346c0,0-13.743,16.922-13.04,18.001c0.975-1.079-4.934-18.186-4.934-18.186s-1.233-3.597-5.102-15.387H81.81H47.812H22.175l-2.56,11.068h19.299h4.579c12.415,0,19.995,5.132,17.878,14.225c-2.287,9.901-13.123,14.128-24.665,14.128H32.39l5.552-24.208H18.647l-8.192,35.368h27.398c20.612,0,40.166-11.067,43.692-25.288c0.617-2.614,0.53-9.185-1.054-13.053c0-0.093-0.091-0.271-0.178-0.537c-0.087-0.093-0.178-0.722,0.178-0.814c0.172-0.092,0.525,0.271,0.525,0.358c0,0,0.179,0.456,0.351,0.813l17.44,50.315l44.404-51.216l18.761-0.092h4.579c12.424,0,20.09,5.132,17.969,14.225c-2.29,9.901-13.205,14.128-24.75,14.128h-4.405L161,19.987h-19.287l-8.198,35.368h27.398c20.611,0,40.343-11.067,43.604-25.288c3.347-14.225-11.101-25.293-31.89-25.293h-18.143h-22.727C120.923,17.823,118.895,20.346,118.895,20.346L118.895,20.346z"/>
      <path d="M99.424,67.329C47.281,67.329,5,73.449,5,81.012c0,7.558,42.281,13.678,94.424,13.678c52.239,0,94.524-6.12,94.524-13.678C193.949,73.449,151.664,67.329,99.424,67.329z M96.078,85.873c-11.98,0-21.58-2.072-21.58-4.595c0-2.523,9.599-4.59,21.58-4.59c11.888,0,21.498,2.066,21.498,4.59C117.576,83.801,107.966,85.873,96.078,85.873z"/>
    </svg>
  </div>
  
  <img id="axex-img" src="../axex.jpg" alt="Axex">
  
  <div id="corner-video-container">
    <video id="corner-video" src="../xfrt.mp4" preload="auto"></video>
  </div>
  
  <div id="retro-clock">
    <div id="clock-time">00:00:00</div>
    <div id="clock-date">MON JAN 01</div>
  </div>
  
  <audio id="podcast" src="../asd.mp3" preload="auto" autoplay></audio>
  
  <script>
    // DOM Elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const textbox = document.getElementById('textbox');
    const podcast = document.getElementById('podcast');
    const audioPlay = document.getElementById('audio-play');
    const audioStop = document.getElementById('audio-stop');
    const audioProgress = document.getElementById('audio-progress');
    const audioTime = document.getElementById('audio-time');
    const volumeSlider = document.getElementById('volume-slider');
    const audioEqualizer = document.getElementById('audio-equalizer');
    const playAgainButton = document.getElementById('play-again-button');
    
    // Game State
    const keys = {};
    let isPlaying = false;
    let gameStarted = false;
    let lastTimestamp = 0;
    
    // Create equalizer bars
    for (let i = 0; i < 5; i++) {
      const eqBar = document.createElement('div');
      eqBar.className = 'eq-bar';
      eqBar.style.height = '3px';
      audioEqualizer.appendChild(eqBar);
    }
    
    const equalizerBars = document.querySelectorAll('.eq-bar');
    
    // Assets to load
    const assets = {
      // Existing assets from the previous level
      player_idle: 'player_idle.png',
      player_walk: 'player_walk.png',
      
      // New assets for level 2
      map: '../assets/cyberpunk_map.png',
      character: '../assets/character.png',
      particles: '../assets/particles.png',
      object1: '../assets/terminal.png',
      object2: '../assets/container.png',
      object3: '../assets/hologram.png',
      glow: '../assets/glow.png',
      tiles: '../assets/cybertiles.png'
    };
    
    // Game objects
    let images = {};
    let player = { 
      x: 384, 
      y: 400, 
      width: 64, 
      height: 64, 
      frame: 0, 
      frameCount: 4,
      animSpeed: 0.15,
      animTimer: 0,
      speed: 3,
      direction: 'down' 
    };
    
    // Environment objects
    const objects = [
      { x: 200, y: 150, width: 80, height: 120, type: 'object1', interactable: true, message: "Terminal displays cryptic messages about 'Project Overseer'" },
      { x: 500, y: 200, width: 100, height: 80, type: 'object2', interactable: true, message: "Container is locked. It's marked 'Biohazard - Level 5 Clearance'" },
      { x: 300, y: 350, width: 60, height: 90, type: 'object3', interactable: true, message: "Holographic display shows blueprints for an underground facility" }
    ];
    
    // Particle system
    const particles = [];
    
    // Lighting system
    const lights = [
      { x: 200, y: 150, radius: 100, intensity: 0.8, color: '#00ff00' },
      { x: 500, y: 200, radius: 120, intensity: 0.7, color: '#00ffff' },
      { x: 300, y: 350, radius: 80, intensity: 0.9, color: '#ff00ff' }
    ];
    
    // Map data
    let map = {
      width: 768,
      height: 576,
      tileSize: 32,
      collision: [] // Will be populated
    };
    
    // Animation frames for objects
    const animations = {
      object3: { frames: 8, current: 0, speed: 0.1, timer: 0 }
    };
    
    // Start the loading sequence
    function startLoadingAnimation() {
      // Skip loading screen and start game immediately
      startGame();
    }
    
    // Start the game after loading
    function startGame() {
      gameStarted = true;
      
      // Auto-play podcast
      playPodcast();
      
      loadAssets(gameLoop);
    }
    
    // Load all game assets
    function loadAssets(callback) {
      let loaded = 0;
      const total = Object.keys(assets).length;
      
      // Create a fallback mechanism for missing assets
      function createFallbackImage(key) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 64;
        canvas.height = 64;
        
        // Draw a placeholder with the key name
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, 64, 64);
        ctx.strokeStyle = '#0f0';
        ctx.strokeRect(0, 0, 64, 64);
        ctx.font = '10px monospace';
        ctx.fillStyle = '#0f0';
        ctx.fillText(key, 5, 32);
        
        const img = new Image();
        img.src = canvas.toDataURL();
        return img;
      }
      
      for (let key in assets) {
        const img = new Image();
        img.src = assets[key];
        
        img.onload = () => {
          images[key] = img;
          if (++loaded === total) callback();
        };
        
        img.onerror = () => {
          console.warn(`Failed to load asset: ${key}`);
          images[key] = createFallbackImage(key);
          if (++loaded === total) callback();
        };
      }
    }
    
    // Render functions
    function draw(timestamp) {
      const delta = timestamp - lastTimestamp;
      lastTimestamp = timestamp;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw the environment
      drawEnvironment();
      
      // Draw objects with depth sorting
      const allEntities = [...objects, player];
      allEntities.sort((a, b) => a.y - b.y);
      
      for (const entity of allEntities) {
        if (entity === player) {
          drawPlayer(delta);
        } else {
          drawObject(entity, delta);
        }
      }
      
      // Apply lighting effects
      applyLighting();
      
      // Draw particles
      updateAndDrawParticles(delta);
      
      // Draw UI elements
      drawUI();
    }
    
    function drawEnvironment() {
      // Draw base map
      if (images.map) {
        ctx.drawImage(images.map, 0, 0, canvas.width, canvas.height);
      } else {
        // Fallback - draw a grid
        ctx.fillStyle = '#0a0a14';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw tiles
        if (images.tiles) {
          const tileSize = map.tileSize;
          for (let y = 0; y < canvas.height; y += tileSize) {
            for (let x = 0; x < canvas.width; x += tileSize) {
              // Use different tile patterns based on position
              const tileType = Math.abs(Math.floor(x / 64) + Math.floor(y / 64)) % 3;
              ctx.drawImage(
                images.tiles,
                tileType * tileSize, 0, tileSize, tileSize,
                x, y, tileSize, tileSize
              );
            }
          }
        }
        
        // Draw grid lines
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
        ctx.lineWidth = 1;
        
        for (let x = 0; x < canvas.width; x += 32) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        
        for (let y = 0; y < canvas.height; y += 32) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
      }
    }
    
    function drawPlayer(delta) {
      // Add clip region to ensure player draws over screensaver
      ctx.save();
      
      // Update animation
      player.animTimer += delta / 1000;
      if (player.animTimer >= player.animSpeed) {
        player.frame = (player.frame + 1) % player.frameCount;
        player.animTimer = 0;
      }
      
      // Determine sprite sheet and frame
      const spritesheet = (keys.w || keys.a || keys.s || keys.d) ? 
        images.player_walk : images.player_idle;
      
      if (!spritesheet) {
        // Fallback for missing player sprite
        ctx.fillStyle = '#0f0';
        ctx.fillRect(player.x - player.width/2, player.y - player.height/2, player.width, player.height);
        ctx.restore();
        return;
      }
      
      // Determine which row in spritesheet to use based on direction
      let directionRow = 0; // Default: down
      switch (player.direction) {
        case 'up': directionRow = 3; break;
        case 'left': directionRow = 1; break;
        case 'right': directionRow = 2; break;
        case 'down': directionRow = 0; break;
      }
      
      // Create a player "spotlight" effect to ensure visibility
      ctx.globalCompositeOperation = 'source-over';
      
      // Draw player with animation frame
      const frameWidth = spritesheet.width / player.frameCount;
      const frameHeight = spritesheet.height / 4; // 4 directions
      
      ctx.drawImage(
        spritesheet,
        player.frame * frameWidth, directionRow * frameHeight, frameWidth, frameHeight,
        player.x - player.width/2, player.y - player.height/2, player.width, player.height
      );
      
      // Draw player shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.beginPath();
      ctx.ellipse(
        player.x, player.y + player.height/2 - 5, 
        player.width/2, player.width/4, 0, 0, Math.PI * 2
      );
      ctx.fill();
      
      // Add a subtle glow effect around player
      if (images.glow) {
        ctx.globalAlpha = 0.2;
        ctx.drawImage(
          images.glow,
          player.x - player.width, player.y - player.height, 
          player.width * 2, player.height * 2
        );
        ctx.globalAlpha = 1.0;
      }
      
      ctx.restore();
    }
    
    function drawObject(obj, delta) {
      const img = images[obj.type];
      if (!img) {
        // Fallback
        ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.fillRect(obj.x - obj.width/2, obj.y - obj.height/2, obj.width, obj.height);
        return;
      }
      
      // Check if object has animation
      if (animations[obj.type]) {
        const anim = animations[obj.type];
        anim.timer += delta / 1000;
        
        if (anim.timer >= anim.speed) {
          anim.current = (anim.current + 1) % anim.frames;
          anim.timer = 0;
        }
        
        const frameWidth = img.width / anim.frames;
        const frameHeight = img.height;
        
        ctx.drawImage(
          img,
          anim.current * frameWidth, 0, frameWidth, frameHeight,
          obj.x - obj.width/2, obj.y - obj.height/2, obj.width, obj.height
        );
      } else {
        // Static object
        ctx.drawImage(
          img,
          obj.x - obj.width/2, obj.y - obj.height/2, obj.width, obj.height
        );
      }
      
      // Draw shadow under object
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.beginPath();
      ctx.ellipse(
        obj.x, obj.y + obj.height/2 - 5, 
        obj.width/2, obj.width/4, 0, 0, Math.PI * 2
      );
      ctx.fill();
      
      // Highlight interactable objects when player is near
      if (obj.interactable) {
        const dx = player.x - obj.x;
        const dy = player.y - obj.y;
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        if (distance < 100) {
          const opacity = 0.5 - (distance / 200);
          ctx.strokeStyle = `rgba(0, 255, 0, ${opacity})`;
          ctx.lineWidth = 2;
          ctx.strokeRect(
            obj.x - obj.width/2, obj.y - obj.height/2, 
            obj.width, obj.height
          );
          
          // Show 'press E' hint when very close
          if (distance < 70) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(obj.x - 20, obj.y - obj.height/2 - 20, 40, 20);
            ctx.fillStyle = '#0f0';
            ctx.font = '12px "Courier New"';
            ctx.fillText('Press E', obj.x - 18, obj.y - obj.height/2 - 5);
          }
        }
      }
    }
    
    function applyLighting() {
      // Create a dark overlay
      ctx.fillStyle = 'rgba(0, 0, 10, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Apply light sources using composite operations
      ctx.globalCompositeOperation = 'lighter';
      
      for (const light of lights) {
        const gradient = ctx.createRadialGradient(
          light.x, light.y, 0,
          light.x, light.y, light.radius
        );
        
        gradient.addColorStop(0, light.color + Math.floor(light.intensity * 99).toString(16));
        gradient.addColorStop(0.5, light.color + Math.floor(light.intensity * 40).toString(16));
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(light.x, light.y, light.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Add player's light
      const playerLight = ctx.createRadialGradient(
        player.x, player.y, 0,
        player.x, player.y, 150
      );
      
      playerLight.addColorStop(0, 'rgba(0, 255, 0, 0.3)');
      playerLight.addColorStop(0.5, 'rgba(0, 255, 0, 0.1)');
      playerLight.addColorStop(1, 'rgba(0, 0, 0, 0)');
      
      ctx.fillStyle = playerLight;
      ctx.beginPath();
      ctx.arc(player.x, player.y, 150, 0, Math.PI * 2);
      ctx.fill();
      
      // Reset composite operation
      ctx.globalCompositeOperation = 'source-over';
    }
    
    function updateAndDrawParticles(delta) {
      // Generate new particles
      if (Math.random() < 0.05) {
        for (const light of lights) {
          if (Math.random() < 0.3) {
            particles.push({
              x: light.x + (Math.random() * 40 - 20),
              y: light.y + (Math.random() * 40 - 20),
              size: Math.random() * 5 + 1,
              speed: Math.random() * 20 + 5,
              life: 1.0,
              color: light.color
            });
          }
        }
      }
      
      // Update and draw particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        
        // Update particle
        p.life -= 0.01 * (delta / 16);
        p.y -= p.speed * (delta / 1000);
        p.size *= 0.98;
        
        // Remove dead particles
        if (p.life <= 0 || p.size < 0.5) {
          particles.splice(i, 1);
          continue;
        }
        
        // Draw particle
        ctx.fillStyle = p.color + Math.floor(p.life * 255).toString(16);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function drawUI() {
      // Additional UI elements can be drawn here
    }
    
    // Game logic update
    function update(delta) {
      updatePlayer(delta);
      checkInteractions();
      updateAudioVisualizer();
    }
    
    function updatePlayer(delta) {
      let dx = 0, dy = 0;
      
      if (keys.w) dy -= player.speed * (delta / 16);
      if (keys.s) dy += player.speed * (delta / 16);
      if (keys.a) dx -= player.speed * (delta / 16);
      if (keys.d) dx += player.speed * (delta / 16);
      
      // Set player direction
      if (Math.abs(dx) > Math.abs(dy)) {
        player.direction = dx < 0 ? 'left' : 'right';
      } else if (dy !== 0) {
        player.direction = dy < 0 ? 'up' : 'down';
      }
      
      // Check for collisions with world boundaries
      const newX = player.x + dx;
      const newY = player.y + dy;
      
      // Boundary checks
      if (newX - player.width/2 > 0 && newX + player.width/2 < canvas.width) {
        player.x = newX;
      }
      
      if (newY - player.height/2 > 0 && newY + player.height/2 < canvas.height) {
        player.y = newY;
      }
      
      // Check collisions with objects
      for (const obj of objects) {
        if (checkCollision(
          { x: newX, y: player.y, width: player.width * 0.8, height: player.height * 0.5 },
          { x: obj.x, y: obj.y, width: obj.width * 0.8, height: obj.height * 0.5 }
        )) {
          player.x = player.x;
        }
        
        if (checkCollision(
          { x: player.x, y: newY, width: player.width * 0.8, height: player.height * 0.5 },
          { x: obj.x, y: obj.y, width: obj.width * 0.8, height: obj.height * 0.5 }
        )) {
          player.y = player.y;
        }
      }
    }
    
    function checkCollision(a, b) {
      return (
        a.x - a.width/2 < b.x + b.width/2 &&
        a.x + a.width/2 > b.x - b.width/2 &&
        a.y - a.height/2 < b.y + b.height/2 &&
        a.y + a.height/2 > b.y - b.height/2
      );
    }
    
    function checkInteractions() {
      // Check if player is near any interactable object and press E
      if (keys.e) {
        for (const obj of objects) {
          if (obj.interactable) {
            const dx = player.x - obj.x;
            const dy = player.y - obj.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            if (distance < 70) {
              textbox.innerText = obj.message;
              // Reset the E key to prevent multiple interactions
              keys.e = false;
              break;
            }
          }
        }
      }
    }
    
    // Update audio visualizer based on audio data
    function updateAudioVisualizer() {
      if (isPlaying && podcast.paused === false) {
        // Create a random visualizer effect
        for (let i = 0; i < equalizerBars.length; i++) {
          const randomHeight = Math.random() * 15 + 3;
          equalizerBars[i].style.height = `${randomHeight}px`;
        }
      } else {
        // Reset equalizer when not playing
        for (let i = 0; i < equalizerBars.length; i++) {
          equalizerBars[i].style.height = '3px';
        }
      }
    }
    
    // Audio playback controls
    function initAudioControls() {
      // Set initial volume
      podcast.volume = volumeSlider.value / 100;
      
      // Format time as MM:SS
      function formatTime(seconds) {
        if (isNaN(seconds) || seconds === Infinity) return "00:00";
        const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
        const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
        return `${mins}:${secs}`;
      }
      
      // Update progress bar and time display
      function updateProgress() {
        if (!podcast.paused) {
          const progress = (podcast.currentTime / podcast.duration) * 100 || 0;
          audioProgress.style.width = `${isNaN(progress) ? 0 : progress}%`;
          
          audioTime.textContent = `${formatTime(podcast.currentTime)} / ${formatTime(podcast.duration)}`;
          requestAnimationFrame(updateProgress);
        }
      }
      
      // Initial time display setup
      podcast.addEventListener('loadedmetadata', () => {
        audioTime.textContent = `00:00 / ${formatTime(podcast.duration)}`;
      });
      
      // Function to play podcast
      function playPodcast() {
        podcast.play().then(() => {
          isPlaying = true;
          audioPlay.textContent = 'PAUSE';
          audioPlay.classList.add('active');
          
          // Start progress tracking
          updateProgress();
          
          // Force an immediate update of the time display
          setTimeout(() => {
            if (!podcast.paused) {
              audioTime.textContent = `${formatTime(podcast.currentTime)} / ${formatTime(podcast.duration)}`;
            }
          }, 500);
        }).catch(error => {
          console.error('Podcast auto-play failed:', error);
          // Some browsers block autoplay. Show a message or add a user gesture requirement.
        });
      }
      
      // Play button
      audioPlay.addEventListener('click', () => {
        if (podcast.paused) {
          playPodcast();
        } else {
          podcast.pause();
          isPlaying = false;
          audioPlay.textContent = 'PLAY';
          audioPlay.classList.remove('active');
        }
      });
      
      // Stop button
      audioStop.addEventListener('click', () => {
        podcast.pause();
        podcast.currentTime = 0;
        isPlaying = false;
        audioPlay.textContent = 'PLAY';
        audioPlay.classList.remove('active');
        audioProgress.style.width = '0%';
        audioTime.textContent = `00:00 / ${formatTime(podcast.duration || 0)}`;
      });
      
      // Volume control
      volumeSlider.addEventListener('input', () => {
        podcast.volume = volumeSlider.value / 100;
      });
      
      // Make progress bar clickable
      document.getElementById('audio-progress-container').addEventListener('click', (e) => {
        const rect = e.target.getBoundingClientRect();
        const pos = (e.clientX - rect.left) / rect.width;
        podcast.currentTime = pos * podcast.duration;
      });
      
      // Loop podcast if it ends
      podcast.addEventListener('ended', () => {
        podcast.currentTime = 0;
        podcast.play().catch(e => console.error('Error looping podcast:', e));
      });
      
      // Update time display when seeking
      podcast.addEventListener('seeked', () => {
        audioTime.textContent = `${formatTime(podcast.currentTime)} / ${formatTime(podcast.duration)}`;
      });
      
      // Handle time updates
      podcast.addEventListener('timeupdate', () => {
        if (podcast.readyState >= 2) {
          const progress = (podcast.currentTime / podcast.duration) * 100 || 0;
          audioProgress.style.width = `${isNaN(progress) ? 0 : progress}%`;
          audioTime.textContent = `${formatTime(podcast.currentTime)} / ${formatTime(podcast.duration)}`;
        }
      });
    }
    
    // Main game loop
    function gameLoop(timestamp) {
      if (!gameStarted) return;
      
      update(timestamp - lastTimestamp);
      draw(timestamp);
      
      lastTimestamp = timestamp;
      requestAnimationFrame(gameLoop);
      
      // Check if player should exit
      checkExit();
      
      // Update dynamic lighting
      updateLights();
    }
    
    // Event listeners
    window.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
    });
    
    window.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });
    
    // Play Again button handler
    playAgainButton.addEventListener('click', () => {
      // Pause audio before navigating
      podcast.pause();
      // Navigate back to the main game
      window.location.href = '../index.html';
    });
    
    // Add an exit path to return to Logos.html
    function checkExit() {
      // If player reaches top of screen, return to main page
      if (player.y < 50) {
        window.location.href = 'Logos.html';
      }
    }
    
    // Create dynamic lighting effects
    function updateLights() {
      for (const light of lights) {
        // Make lights "breathe"
        light.intensity = 0.5 + Math.sin(Date.now() / 1000) * 0.3;
        
        // Add subtle position variations
        light.x += Math.sin(Date.now() / 1500) * 0.3;
        light.y += Math.cos(Date.now() / 1500) * 0.3;
      }
    }
    
    // Initialize and start the game
    function init() {
      initAudioControls();
      
      // Initialize retro clock
      updateClock();
      setInterval(updateClock, 1000);
      
      // Add global playPodcast function for use elsewhere
      window.playPodcast = function() {
        podcast.play().then(() => {
          isPlaying = true;
          audioPlay.textContent = 'PAUSE';
          audioPlay.classList.add('active');
          updateProgress();
        }).catch(error => {
          console.error('Failed to play podcast:', error);
        });
      };
      
      startLoadingAnimation();
      
      // Setup an event listener to play audio after a user gesture if autoplay failed
      document.addEventListener('click', function initPlay() {
        if (podcast.paused) {
          playPodcast();
          // Remove the event listener after it's been used
          document.removeEventListener('click', initPlay);
        }
      }, {once: true});
      
      // Generate map collision data
      for (let y = 0; y < map.height; y += map.tileSize) {
        for (let x = 0; x < map.width; x += map.tileSize) {
          // Add edge boundaries
          if (x === 0 || y === 0 || x === map.width - map.tileSize || y === map.height - map.tileSize) {
            map.collision.push({ x, y, width: map.tileSize, height: map.tileSize });
          }
        }
      }
    }
    
    // Start the game
    init();
    
    // Initialize DVD Screensaver
    const dvdLogo = document.getElementById('dvd-logo');
    const dvdPaths = dvdLogo.querySelectorAll('path');
    const cornerVideo = document.getElementById('corner-video');
    const cornerVideoContainer = document.getElementById('corner-video-container');
    let dvdX = Math.random() * (window.innerWidth - 150);
    let dvdY = Math.random() * (window.innerHeight - 80);
    let dvdSpeedX = 1.5;
    let dvdSpeedY = 1.5;
    let currentColor = 0;
    let isCornerHit = false;
    
    // Color palette for DVD logo
    const colors = [
      '#ff0000', // Red
      '#00ff00', // Green
      '#0000ff', // Blue
      '#ffff00', // Yellow
      '#ff00ff', // Magenta
      '#00ffff', // Cyan
      '#ff8000', // Orange
      '#8000ff'  // Purple
    ];
    
    // Set initial color
    function setDvdColor(color) {
      dvdPaths.forEach(path => {
        path.style.fill = color;
      });
    }
    
    // Set initial position and color
    dvdLogo.style.left = dvdX + 'px';
    dvdLogo.style.top = dvdY + 'px';
    setDvdColor(colors[currentColor]);
    
    // Function to update DVD position and handle collisions
    function updateDVD() {
      if (isCornerHit) return; // Pause animation while video is playing
      
      const oldX = dvdX;
      const oldY = dvdY;
      
      dvdX += dvdSpeedX;
      dvdY += dvdSpeedY;
      
      const maxX = window.innerWidth - 150;
      const maxY = window.innerHeight - 80;
      
      // Check for horizontal collision
      const hitLeft = dvdX <= 0 && oldX > 0;
      const hitRight = dvdX >= maxX && oldX < maxX;
      
      // Check for vertical collision
      const hitTop = dvdY <= 0 && oldY > 0;
      const hitBottom = dvdY >= maxY && oldY < maxY;
      
      // Bounce logic
      if (hitLeft || hitRight) {
        dvdSpeedX = -dvdSpeedX;
        changeColor();
      }
      
      if (hitTop || hitBottom) {
        dvdSpeedY = -dvdSpeedY;
        changeColor();
      }
      
      // Ensure within bounds
      dvdX = Math.max(0, Math.min(dvdX, maxX));
      dvdY = Math.max(0, Math.min(dvdY, maxY));
      
      // Check for corner hit
      if ((hitLeft || hitRight) && (hitTop || hitBottom)) {
        playCornerVideo();
      }
      
      // Apply position
      dvdLogo.style.left = dvdX + 'px';
      dvdLogo.style.top = dvdY + 'px';
      
      // Request next animation frame
      requestAnimationFrame(updateDVD);
    }
    
    // Change DVD logo color
    function changeColor() {
      currentColor = (currentColor + 1) % colors.length;
      setDvdColor(colors[currentColor]);
    }
    
    // Play video when DVD hits a corner
    function playCornerVideo() {
      isCornerHit = true;
      cornerVideoContainer.style.display = 'flex';
      
      // Pause podcast audio
      if (!podcast.paused) {
        podcast.pause();
      }
      
      cornerVideo.play();
      
      // Add event listener to close video when it ends
      cornerVideo.onended = function() {
        cornerVideoContainer.style.display = 'none';
        isCornerHit = false;
        
        // Resume podcast if it was playing
        if (isPlaying) {
          podcast.play().catch(error => {
            console.error('Failed to resume podcast:', error);
          });
        }
      };
      
      // Also add click to close
      cornerVideoContainer.onclick = function() {
        cornerVideo.pause();
        cornerVideo.currentTime = 0;
        cornerVideoContainer.style.display = 'none';
        isCornerHit = false;
        
        // Resume podcast if it was playing
        if (isPlaying) {
          podcast.play().catch(error => {
            console.error('Failed to resume podcast:', error);
          });
        }
      };
    }
    
    // Update DVD on window resize
    window.addEventListener('resize', () => {
      // Keep DVD logo within bounds
      if (dvdX > window.innerWidth - 150) dvdX = window.innerWidth - 150;
      if (dvdY > window.innerHeight - 80) dvdY = window.innerHeight - 80;
    });
    
    // Start DVD animation
    updateDVD();
    
    // Retro clock functionality
    function updateClock() {
      const now = new Date();
      const clockTime = document.getElementById('clock-time');
      const clockDate = document.getElementById('clock-date');
      
      // Format time as HH:MM:SS with blinking separator
      const hours = now.getHours().toString().padStart(2, '0');
      const minutes = now.getMinutes().toString().padStart(2, '0');
      const seconds = now.getSeconds().toString().padStart(2, '0');
      
      // Create blinking separators that match the old LED/LCD display effect
      const blinkOpacity = now.getSeconds() % 2 === 0 ? '1' : '0.2';
      const separatorStyle = `style="opacity:${blinkOpacity}"`;
      
      // Add randomized "glitch" effect occasionally (once every ~30 seconds)
      let timeDisplay = `${hours}<span ${separatorStyle}>:</span>${minutes}<span style="opacity:0.8">:${seconds}</span>`;
      
      if (Math.random() < 0.005) {
        // Create a glitch effect by momentarily scrambling some digits
        const glitchChars = ['8', '0', '3', '5', '7', '/', '\\', '*']; 
        const glitchChar = glitchChars[Math.floor(Math.random() * glitchChars.length)];
        const glitchIndex = Math.floor(Math.random() * 8); // Position in the time display
        
        // Replace a character with a glitch character
        if (glitchIndex < timeDisplay.length) {
          const glitchStyle = 'style="opacity:0.9;color:#ff0;text-shadow:0 0 5px #ff0"';
          timeDisplay = timeDisplay.substring(0, glitchIndex) + 
                       `<span ${glitchStyle}>${glitchChar}</span>` + 
                       timeDisplay.substring(glitchIndex + 1);
        }
      }
      
      // Format date as DAY MONTH DD
      const days = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
      const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
      const day = days[now.getDay()];
      const month = months[now.getMonth()];
      const date = now.getDate().toString().padStart(2, '0');
      const year = now.getFullYear().toString();
      
      // Update clock display
      clockTime.innerHTML = timeDisplay;
      clockDate.textContent = `${day} ${month} ${date} ${year.substring(2)}`;
      
      // Add slight CRT scan effect
      const scanEffect = Math.sin(Date.now() / 1000) * 0.5 + 0.5;
      clockTime.style.textShadow = `0 0 5px rgba(0, 255, 0, ${scanEffect + 0.5})`;
    }
  </script>
</body>
</html> 